# 阶段一：核心基础设施与连接性验证（“你好，立方体”里程碑）

- [x] 子任务1.1：在CMake项目中，选择并集成C++ WebSocket库（如WebSocket++）及其依赖（如Boost.Asio）。  
- [x] 子任务1.2：实现一个极简的C++服务器，能够接受WebSocket连接并发送一条硬编码的文本消息。  
- [x] 子任务1.3：创建一个基础的HTML/JS前端页面，能够连接到上述服务器，并在浏览器的控制台中打印出收到的消息。  
- [x] 子任务1.4：将Protobuf编译器集成到前后端的构建流程中。定义一个最小的.proto文件（例如，只包含一个字符串字段的TestMessage）。  
- [x] 子任务1.5：修改服务器和客户端，使其能够成功交换Protobuf格式的二进制TestMessage。验证点：至此，整个通信管道（C++ -> WebSocket -> Protobuf -> JS）已完全打通。  

# 阶段二：基础可视化图元渲染（端到端功能实现）

- [ ] 子任务2.1：在.proto文件中，完整设计并实现用于创建点云的AddObject指令（包含Points几何体和Material）。  
- [ ] 子任务2.2：在C++ VisualizationServer类中，实现add_points公共API方法。  
- [ ] 子任务2.3：在前端ObjectFactory.js中，实现接收Points指令并创建相应THREE.Points对象的逻辑。  
- [ ] 子任务2.4：实现UpdateObjectGeometry指令和前端高效的缓冲区更新机制，以支持动态更新点云位置。  
- [ ] 子任务2.5：重复2.1至2.4的流程，实现对LineStrip（折线）图元的支持。验证点：此时，系统已具备了绘制和动态更新两种核心图元的能力。  

# 阶段三：高级功能与UI元素

- [ ] 子任务3.1：扩展后端API和前端工厂，支持更复杂的几何体，如Surface（曲面）、Vector（向量）以及简单的封闭几何体（立方体、球体等）。  
- [ ] 子任务3.2：在前端实现混合渲染系统。集成THREE.GridHelper和THREE.AxesHelper来绘制网格和坐标轴。  
- [ ] 子任务3.3：集成CSS2DRenderer。在.proto中定义用于创建和更新HTML标签的指令。在前端实现接收指令、创建HTML元素并将其位置与3D场景同步的逻辑。  
- [ ] 子任务3.4：在后端VisualizationServer中，实现完整的多窗口管理机制，包括连接ID的生成、映射和API调用时的数据路由。  

# 阶段四：优化、集成与部署

- [ ] 子任务4.1：进行系统性能分析和优化。使用性能剖析工具检查序列化开销、网络传输瓶颈和前端渲染帧率，并进行针对性优化。  
- [ ] 子任务4.2：编写pybind11封装代码，为VisualizationServer类创建Python模块，并进行充分测试。  
- [ ] 子任务4.3：为C++和Python API编写详尽的文档和使用示例，降低用户的学习成本。  
- [ ] 子任务4.4：在目标Ubuntu和Windows系统上进行全面的跨平台兼容性测试，解决可能出现的编译或运行时问题。将前端资源打包，以便于部署。  
